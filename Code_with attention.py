# -*- coding: utf-8 -*-
"""bolt_dualconv_with_attention_1_(1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1imSRqrXmPsu8S9UAlahD6617w7B87XJ3

# <font style="color:blue">Table of Content</font>
"""

from google.colab import drive
drive.mount('/content/drive')

"""# <font style="color:blue">1. Training Utils</font><a name="utils"></a>"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import matplotlib.pyplot as plt  # one of the best graphics library for python
plt.style.use('ggplot')

import os
import time

from typing import Iterable
from dataclasses import dataclass

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F

from torchvision import datasets, transforms, models

from torch.optim import lr_scheduler

# Commented out IPython magic to ensure Python compatibility.
# %pip install -q torchcam

def image_preprocess_transforms():

    preprocess = transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        ])

    return preprocess

def image_common_transforms(mean=(0.4611, 0.4359, 0.3905), std=(0.2193, 0.2150, 0.2109)):
    preprocess = image_preprocess_transforms()

    common_transforms = transforms.Compose([
        preprocess,
        transforms.Normalize(mean, std)
    ])

    return common_transforms

def get_mean_std(data_root, num_workers=4):

    transform = image_preprocess_transforms()

    loader = data_loader(data_root, transform)

    mean = 0.
    std = 0.

    for images, _ in loader:
        batch_samples = images.size(0) # batch size (the last batch can have smaller size!)
        images = images.view(batch_samples, images.size(1), -1)
        mean += images.mean(2).sum(0)
        std += images.std(2).sum(0)

    mean /= len(loader.dataset)
    std /= len(loader.dataset)

    print('mean: {}, std: {}'.format(mean, std))

    return mean, std

def data_augmentation_preprocess(mean, std):

    initail_transoform = transforms.RandomChoice([
        transforms.RandomHorizontalFlip(),
        transforms.RandomVerticalFlip(),
        transforms.RandomRotation(90)
        ])

    common_transforms = image_common_transforms(mean, std)

    aug_transforms = transforms.Compose([
        initail_transoform,
        transforms.RandomGrayscale(p=0.1),
        common_transforms,
        transforms.RandomErasing()
        ])

    return aug_transforms

def data_loader(data_root, transform, batch_size=16, shuffle=False, num_workers=2):
    dataset = datasets.ImageFolder(root=data_root, transform=transform)

    loader = torch.utils.data.DataLoader(dataset,
                                         batch_size=batch_size,
                                         num_workers=num_workers,
                                         shuffle=shuffle)

    return loader

def get_data(batch_size, data_root, num_workers=4, data_augmentation=False):
#     YOUR CODE HERE
  train_data_path = os.path.join(data_root, 'training')

  mean, std = get_mean_std(data_root=train_data_path, num_workers=num_workers)

  common_transforms = image_common_transforms(mean, std)


    # if data_augmentation is true
    # data augmentation implementation
  if data_augmentation:
      train_transforms = data_augmentation_preprocess(mean, std)
    # else do common transforms
  else:
      train_transforms = common_transforms


    # train dataloader

  train_loader = data_loader(train_data_path,
                               train_transforms,
                               batch_size=batch_size,
                               shuffle=True,
                               num_workers=num_workers)

    # test dataloader

  test_data_path = os.path.join(data_root, 'validation')

  test_loader = data_loader(test_data_path,
                              common_transforms,
                              batch_size=batch_size,
                              shuffle=False,
                              num_workers=num_workers)

  return train_loader, test_loader

"""## <font style="color:green">1.2. System Configuration</font>"""

@dataclass
class SystemConfiguration:
    '''
    Describes the common system setting needed for reproducible training
    '''
    seed: int = 21  # seed number to set the state of all random number generators
    cudnn_benchmark_enabled: bool = True  # enable CuDNN benchmark for the sake of performance
    cudnn_deterministic: bool = True  # make cudnn deterministic (reproducible training)

"""## <font style="color:green">1.3. Training Configuration</font> EDIT"""

from dataclasses import dataclass, field
from typing import List
@dataclass
class TrainingConfiguration:
    '''
    Describes configuration of the training process
    '''
    batch_size: int = 32
    epochs_count: int = 40
    init_learning_rate: float = 0.02  # initial learning rate for lr scheduler
    decay_rate: float = 0.1
    log_interval: int = 500
    test_interval: int = 1
    data_root: str = "/content/drive/MyDrive/Project/Dataset" #--------ADD YOUR DATA HERE
    num_workers: int = 10
    device: str = 'cuda'
    class_names: List[str] = field(default_factory=lambda: ['HAPPY', 'SAD'])

"""## <font style="color:green">1.4. System Setup</font>"""

def setup_system(system_config: SystemConfiguration) -> None:
    torch.manual_seed(system_config.seed)
    if torch.cuda.is_available():
        torch.backends.cudnn_benchmark_enabled = system_config.cudnn_benchmark_enabled
        torch.backends.cudnn.deterministic = system_config.cudnn_deterministic

"""## <font style="color:green">1.5. Training Function</font>

You are familiar with the training pipeline used in PyTorch.
"""

def train(
    train_config: TrainingConfiguration, model: nn.Module, optimizer: torch.optim.Optimizer,
    train_loader: torch.utils.data.DataLoader, epoch_idx: int
) -> None:

    # change model in training mode
    model.train()

    # to get batch loss
    batch_loss = np.array([])

    # to get batch accuracy
    batch_acc = np.array([])

    for batch_idx, (data, target) in enumerate(train_loader):

        # clone target
        indx_target = target.clone()
        # send data to device (it is mandatory if GPU has to be used)
        data = data.to(train_config.device)
        # send target to device
        target = target.to(train_config.device)

        # reset parameters gradient to zero
        optimizer.zero_grad()

        # forward pass to the model
        output = model(data)

        # cross entropy loss
        loss = F.cross_entropy(output, target)

        # find gradients w.r.t training parameters
        loss.backward()
        # Update parameters using gradients
        optimizer.step()

        batch_loss = np.append(batch_loss, [loss.item()])

        # get probability score using softmax
        prob = F.softmax(output, dim=1)

        # get the index of the max probability
        pred = prob.data.max(dim=1)[1]

        # correct prediction
        correct = pred.cpu().eq(indx_target).sum()

        # accuracy
        acc = float(correct) / float(len(data))

        batch_acc = np.append(batch_acc, [acc])

#         if batch_idx % train_config.log_interval == 0 and batch_idx > 0:
#             print(
#                 'Train Epoch: {} [{}/{}] Loss: {:.6f} Acc: {:.4f}'.format(
#                     epoch_idx, batch_idx * len(data), len(train_loader.dataset), loss.item(), acc
#                 )
#             )

    epoch_loss = batch_loss.mean()
    epoch_acc = batch_acc.mean()
    print('Epoch: {} Train Loss: {:.6f} Acc: {:.4f}'.format(
                epoch_idx, epoch_loss, epoch_acc))
    return epoch_loss, epoch_acc

"""## <font style="color:green">1.6. Validation Function</font>"""

def validate(
    train_config: TrainingConfiguration,
    model: nn.Module,
    test_loader: torch.utils.data.DataLoader,
) -> float:
    #
    model.eval()
    test_loss = 0
    count_corect_predictions = 0
    for data, target in test_loader:
        indx_target = target.clone()
        data = data.to(train_config.device)

        target = target.to(train_config.device)

        output = model(data)
        # add loss for each mini batch
        test_loss += F.cross_entropy(output, target).item()

        # get probability score using softmax
        prob = F.softmax(output, dim=1)

        # get the index of the max probability
        pred = prob.data.max(dim=1)[1]

        # add correct prediction count
        count_corect_predictions += pred.cpu().eq(indx_target).sum()

    # average over number of mini-batches
    test_loss = test_loss / len(test_loader)

    # average over number of dataset
    accuracy = 100. * count_corect_predictions / len(test_loader.dataset)

    print(
        '\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
            test_loss, count_corect_predictions, len(test_loader.dataset), accuracy
        )
    )

    return test_loss, accuracy/100.0

def save_model(model, device, model_dir='models', model_file_name='cnn_model.pt'):


    if not os.path.exists(model_dir):
        os.makedirs(model_dir)

    model_path = os.path.join(model_dir, model_file_name)

    # make sure you transfer the model to cpu.
    if device == 'cuda':
        model.to('cpu')

    # save the state_dict
    torch.save(model.state_dict(), model_path)

    if device == 'cuda':
        model.to('cuda')

    return

def load_model(model, model_dir='models', model_file_name='cnn_model.pt'):
    model_path = os.path.join(model_dir, model_file_name)

    # loading the model and getting model parameters by using load_state_dict
    model.load_state_dict(torch.load(model_path))

    return model

"""## <font style="color:green">1.7. Main Function for Training and Validation</font>

For this, use the configuration parameters defined above, and start training. Action points in the code below:

1. Set up system parameters like CPU/GPU, number of threads etc.


2. Load the data using dataloaders.


3. For each epoch, call  the train function. For every test interval, call validation.



4. Do `scheduler.step()` to update the learning rate for next epoch.


5. Set up variables to track loss and accuracy and start training.
"""

def main(model, optimizer, scheduler=None, system_configuration=SystemConfiguration(),
         training_configuration=TrainingConfiguration(), data_augmentation=False):

    # system configuration
    setup_system(system_configuration)

    # batch size
    batch_size_to_set = training_configuration.batch_size
    # num_workers
    num_workers_to_set = training_configuration.num_workers
    # epochs
    epoch_num_to_set = training_configuration.epochs_count

    # if GPU is available use training config,
    # else lower batch_size, num_workers and epochs count
    if torch.cuda.is_available():
        device = "cuda"
    else:
        device = "cpu"
        batch_size_to_set = 16
        num_workers_to_set = 2

    # data loader
    train_loader, test_loader = get_data(
        batch_size=batch_size_to_set,
        data_root=training_configuration.data_root,
        num_workers=num_workers_to_set,
        data_augmentation=data_augmentation
    )

    # Update training configuration
    training_configuration = TrainingConfiguration(
        device=device,
        batch_size=batch_size_to_set,
        num_workers=num_workers_to_set
    )

    # send model to device (GPU/CPU)
    model.to(training_configuration.device)

    best_loss = torch.tensor(np.inf)

    # epoch train/test loss
    epoch_train_loss = np.array([])
    epoch_test_loss = np.array([])

    # epoch train/test accuracy
    epoch_train_acc = np.array([])
    epoch_test_acc = np.array([])

    # training time measurement
    t_begin = time.time()
    for epoch in range(training_configuration.epochs_count):

        # Train
        train_loss, train_acc = train(training_configuration, model, optimizer, train_loader, epoch)

        epoch_train_loss = np.append(epoch_train_loss, [train_loss])

        epoch_train_acc = np.append(epoch_train_acc, [train_acc])

        elapsed_time = time.time() - t_begin
        speed_epoch = elapsed_time / (epoch + 1)
        speed_batch = speed_epoch / len(train_loader)
        eta = speed_epoch * training_configuration.epochs_count - elapsed_time

        print(
            "Elapsed {:.2f}s, {:.2f} s/epoch, {:.2f} s/batch, ets {:.2f}s".format(
                elapsed_time, speed_epoch, speed_batch, eta
            )
        )

        # Validate
        if epoch % training_configuration.test_interval == 0:
            current_loss, current_accuracy = validate(training_configuration, model, test_loader)

            epoch_test_loss = np.append(epoch_test_loss, [current_loss])

            epoch_test_acc = np.append(epoch_test_acc, [current_accuracy])

            if current_loss < best_loss:
                best_loss = current_loss
                # print('Model Improved. Saving the Model...\n')
                # save_model(model, device=training_configuration.device)

        # scheduler step/ update learning rate
        if scheduler is not None:
            scheduler.step()


    print("Total time: {:.2f}, Best Loss: {:.3f}".format(time.time() - t_begin, best_loss))

    return model, epoch_train_loss, epoch_train_acc, epoch_test_loss, epoch_test_acc

"""## <font style="color:green">1.8. Optimizer and Scheduler</font>

Let's write optimizer and scheduler as a method because we have to use it in all training experiments.
"""

def get_optimizer_and_scheduler(model):
    train_config = TrainingConfiguration()

    init_learning_rate = train_config.init_learning_rate

    # optimizer
    optimizer = optim.SGD(
        model.parameters(),
        lr = init_learning_rate,
        momentum = 0.9
    )

    decay_rate = train_config.decay_rate

    lmbda = lambda epoch: 1/(1 + decay_rate * epoch)

    # Scheduler
    scheduler = lr_scheduler.LambdaLR(optimizer, lr_lambda=lmbda)

    return optimizer, scheduler

"""## <font style="color:green">1.9. Plot Loss and Accuracy</font>"""

def plot_loss_accuracy(train_loss, val_loss, train_acc, val_acc, labels, colors, model_sizes,
                       loss_legend_loc='upper center', acc_legend_loc='upper left', legend_font=15,
                       fig_size=(16, 8), sub_plot1=(1, 2, 1), sub_plot2=(1, 2, 2)):

    plt.rcParams["figure.figsize"] = fig_size
    plt.figure

    plt.subplot(sub_plot1[0], sub_plot1[1], sub_plot1[2])

    for i in range(len(train_loss)):
        x_train = range(len(train_loss[i]))
        x_val = range(len(val_loss[i]))

        min_train_loss = train_loss[i].min()

        min_val_loss = val_loss[i].min()

        plt.plot(x_train, train_loss[i], linestyle='-', color='tab:{}'.format(colors[i]),
                 label="[{2}] TRAIN ({0:.4}): {1}".format(min_train_loss, labels[i], model_sizes[i]))
        plt.plot(x_val, val_loss[i], linestyle='--' , color='tab:{}'.format(colors[i]),
                 label="[{2}] VALID ({0:.4}): {1}".format(min_val_loss, labels[i], model_sizes[i]))

    plt.xlabel('epoch no.')
    plt.ylabel('loss')
    plt.legend(loc=loss_legend_loc, prop={'size': legend_font})
    plt.title('Training and Validation Loss')

    plt.subplot(sub_plot2[0], sub_plot2[1], sub_plot2[2])

    for i in range(len(train_acc)):
        x_train = range(len(train_acc[i]))
        x_val = range(len(val_acc[i]))

        max_train_acc = train_acc[i].max()

        max_val_acc = val_acc[i].max()

        plt.plot(x_train, train_acc[i], linestyle='-', color='tab:{}'.format(colors[i]),
                 label="[{2}] TRAIN ({0:.4}): {1}".format(max_train_acc, labels[i], model_sizes[i]))
        plt.plot(x_val, val_acc[i], linestyle='--' , color='tab:{}'.format(colors[i]),
                 label="[{2}] VALID ({0:.4}): {1}".format(max_val_acc, labels[i], model_sizes[i]))

    plt.xlabel('epoch no.')
    plt.ylabel('accuracy')
    plt.legend(loc=acc_legend_loc, prop={'size': legend_font})
    plt.title('Training and Validation Accuracy')

    plt.show()

    return

"""## 1.9.1 Plotting Gradcam"""

import random
from torchcam.methods import SmoothGradCAMpp
import matplotlib.pyplot as plt
from torchcam.utils import overlay_mask
from torchvision.transforms.functional import  to_pil_image
from torchcam.methods import SmoothGradCAMpp

def plot_gradcam(model, target_layer="_body" ):
  model.eval()

  target_layer = None if target_layer == 'last_layer' else target_layer
  device = 'cuda' if torch.cuda.is_available() else 'gpu'

  _, test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
  test_data = test_dataloader.dataset
  class_names = TrainingConfiguration().class_names

  preprocess = transforms.Compose([
      transforms.Resize(224),
      transforms.ToTensor(),
      ])
  preprocessed_data = datasets.ImageFolder(root=os.path.join(TrainingConfiguration.data_root, 'validation'), transform=preprocess)

  rows, cols = 4, 4
  random_idx = random.sample(range(1, len(test_data)), rows*cols)

  fig = plt.figure(figsize=(15, 15))
  fig.suptitle(' Test Images ', fontsize=30)


  for i in range(1, rows * cols + 1):
      img, label = preprocessed_data[random_idx[i-1]]
      fig.add_subplot(rows, cols, i)
      plt.imshow(img.permute(1,2,0))
      plt.title(class_names[label])
      plt.axis(False);

  fig = plt.figure(figsize=(15, 15))
  fig.suptitle(' Heat Maps for the test images ', fontsize=30)
  for i in range(1, rows * cols + 1):
      img, label = test_data[random_idx[i-1]]
      fig.add_subplot(rows, cols, i)
      with SmoothGradCAMpp(model, input_shape = (3,224,224), target_layer=target_layer) as cam_extractor:
      # Preprocess your data and feed it to the model
          out = model(img.to(device).unsqueeze(0))
          # Retrieve the CAM by passing the class index and the model output
          activation_map = cam_extractor(out.squeeze(0).argmax().item(), out)
      plt.imshow(activation_map[0].cpu().squeeze(0).numpy())
      plt.title(class_names[label])
      plt.axis(False);


  fig = plt.figure(figsize=(15, 15))
  fig.suptitle(' Overlayed Heat maps on the test images ', fontsize=30)
  for i in range(1, rows * cols + 1):
      img, label = test_data[random_idx[i-1]]
      pre_process_img, _ = preprocessed_data[random_idx[i-1]]

      fig.add_subplot(rows, cols, i)
      with SmoothGradCAMpp(model, input_shape = (3,224,224), target_layer=target_layer) as cam_extractor:
      # Preprocess your data and feed it to the model
          out = model(img.to(device).unsqueeze(0))
          # Retrieve the CAM by passing the class index and the model output
          activation_map = cam_extractor(out.squeeze(0).argmax().item(), out)
      result = overlay_mask(to_pil_image(pre_process_img), to_pil_image(activation_map[0].squeeze(0), mode='F'), alpha=0.5)

      plt.imshow(result)
      plt.title(class_names[label])
      plt.axis(False);

"""## 1.9.2 Plot Confusion Matrix"""

def print_confusion_matrix(confusion_matrix, class_names, figsize = (10,7), fontsize=14):
    """Prints a confusion matrix, as returned by sklearn.metrics.confusion_matrix, as a heatmap.

    Note that due to returning the created figure object, when this funciton is called in a
    notebook the figure willl be printed twice. To prevent this, either append ; to your
    function call, or modify the function by commenting out the return expression.

    Arguments
    ---------
    confusion_matrix: numpy.ndarray
        The numpy.ndarray object returned from a call to sklearn.metrics.confusion_matrix.
        Similarly constructed ndarrays can also be used.
    class_names: list
        An ordered list of class names, in the order they index the given confusion matrix.
    figsize: tuple
        A 2-long tuple, the first value determining the horizontal size of the ouputted figure,
        the second determining the vertical size. Defaults to (10,7).
    fontsize: int
        Font size for axes labels. Defaults to 14.

    Returns
    -------
    matplotlib.figure.Figure
        The resulting confusion matrix figure
    """
    df_cm = pd.DataFrame(
        confusion_matrix, index=class_names, columns=class_names,
    )
    fig = plt.figure(figsize=figsize)
    try:
        heatmap = sns.heatmap(df_cm, annot=True, fmt="d")
    except ValueError:
        raise ValueError("Confusion matrix values must be integers.")
    heatmap.yaxis.set_ticklabels(heatmap.yaxis.get_ticklabels(), rotation=0, ha='right', fontsize=fontsize)
    heatmap.xaxis.set_ticklabels(heatmap.xaxis.get_ticklabels(), rotation=45, ha='right', fontsize=fontsize)
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    # Note that due to returning the created figure object, when this funciton is called in a notebook
    # the figure willl be printed twice. To prevent this, either append ; to your function call, or
    # modify the function by commenting out this return expression.
    return fig

"""# <font style="color:blue">2. Model 1: Small Custom Model [S]</font> <a name="model-1"></a>"""

class SmallModel(nn.Module):
    def __init__(self):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11

            #nn.Conv2d(in_channels=4, out_channels=8, kernel_size=3),
            #nn.ReLU(inplace=True),
            #nn.MaxPool2d(kernel_size=2),
            #54x54x8
        )

        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=5 * 111 * 111, out_features=40),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=40, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

model = SmallModel()
print(model)

# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, train_loss_exp1, train_acc_exp1, val_loss_exp1, val_acc_exp1 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp1],
                   val_loss=[val_loss_exp1],
                   train_acc=[train_acc_exp1],
                   val_acc=[val_acc_exp1],
                   labels=['Initial Model'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

TrainingConfiguration().class_names

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

class SmallModel(nn.Module):
    def __init__(self):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11

            nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #54x54x22
        )

        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

"""## <font style="color:green">2.1. Experiment 1: Without Regularization [S]</font><a name="S-without"></a>"""

model = SmallModel()
print(model)

# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, train_loss_exp2, train_acc_exp2, val_loss_exp2, val_acc_exp2 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp2],
                   val_loss=[val_loss_exp2],
                   train_acc=[train_acc_exp2],
                   val_acc=[val_acc_exp2],
                   labels=['Dual-conv Model'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## 2.2 Experiment 2: With Attention Block (Squeeze and Excited block)"""

from torch import nn

class SE_Block(nn.Module):
    def __init__(self, channel, reduction=16):
        super(SE_Block, self).__init__()
        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.fc = nn.Sequential(
            nn.Linear(channel, channel // reduction, bias=False),
            nn.ReLU(inplace=True),
            nn.Linear(channel // reduction, channel, bias=False),
            nn.Sigmoid()
        )

    def forward(self, x):
        b, c, _, _ = x.size()
        y = self.avg_pool(x).view(b, c)
        y = self.fc(y).view(b, c, 1, 1)
        return x * y.expand_as(x)

class SmallModelWithAttention(nn.Module):
    def __init__(self):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11
            SE_Block(channel=5, reduction=16),

            nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #54x54x22
        )
        self.features_conv = self._body[:5]
        self.gradients = None
        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

    # method for the gradient extraction
    def get_activations_gradient(self):
        return self.gradients

    # method for the activation exctraction
    def get_activations(self, x):
        return self.features_conv(x)

model = SmallModelWithAttention()
print(model)

# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, train_loss_exp3, train_acc_exp3, val_loss_exp3, val_acc_exp3 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp3],
                   val_loss=[val_loss_exp3],
                   train_acc=[train_acc_exp3],
                   val_acc=[val_acc_exp3],
                   labels=['Conv with Attention SE'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## 2.3 Experiment 3: With Convolutional Block Attention Module (Channel Attention + Spatial Attention)"""

import torch
import torch.nn as nn

class channel_attention_module(nn.Module):
    def __init__(self, ch, ratio=8):
        super().__init__()

        self.avg_pool = nn.AdaptiveAvgPool2d(1)
        self.max_pool = nn.AdaptiveMaxPool2d(1)

        self.mlp = nn.Sequential(
            nn.Linear(ch, ch//ratio, bias=False),
            nn.ReLU(inplace=True),
            nn.Linear(ch//ratio, ch, bias=False)
        )

        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x1 = self.avg_pool(x).squeeze(-1).squeeze(-1)
        x1 = self.mlp(x1)

        x2 = self.max_pool(x).squeeze(-1).squeeze(-1)
        x2 = self.mlp(x2)

        feats = x1 + x2
        feats = self.sigmoid(feats).unsqueeze(-1).unsqueeze(-1)
        refined_feats = x * feats

        return refined_feats


class spatial_attention_module(nn.Module):
    def __init__(self, kernel_size=7):
        super().__init__()

        self.conv = nn.Conv2d(2, 1, kernel_size, padding=3, bias=False)
        self.sigmoid = nn.Sigmoid()

    def forward(self, x):
        x1 = torch.mean(x, dim=1, keepdim=True)
        x2, _ = torch.max(x, dim=1, keepdim=True)

        feats = torch.cat([x1, x2], dim=1)
        feats = self.conv(feats)
        feats = self.sigmoid(feats)
        refined_feats = x * feats

        return refined_feats

class CBAM_Block(nn.Module):
    def __init__(self, channel):
        super().__init__()

        self.ca = channel_attention_module(channel)
        self.sa = spatial_attention_module()

    def forward(self, x):
        x = self.ca(x)
        x = self.sa(x)
        return x

class SmallModelWithCBAN(nn.Module):
    def __init__(self):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11

            CBAM_Block(channel=5),

            nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #54x54x22
        )

        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

model = SmallModelWithCBAN()
print(model)

# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, train_loss_exp4, train_acc_exp4, val_loss_exp4, val_acc_exp4 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp4],
                   val_loss=[val_loss_exp4],
                   train_acc=[train_acc_exp4],
                   val_acc=[val_acc_exp4],
                   labels=['Conv with Attention CBAM'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## <font style="color:green">2.4 Experiment **4**: With Batch-Norm [M]</font><a name="M-with_BN"></a>

Batch norm is familiar. Now, see if it can reduce overfitting. Add batch normalization to the network and train it.
"""

###
class Model(nn.Module):
    def __init__(self, dropout=0.0, batch_norm=False):
        super().__init__()

        # convolution layers
        if batch_norm:
            self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.BatchNorm2d(5),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11

            nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
            nn.BatchNorm2d(11),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            nn.Dropout(dropout)
            #54x54x22
        )
        else:
            self._body = nn.Sequential(
            nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            #output 111x111x11

            nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
            nn.ReLU(inplace=True),
            nn.MaxPool2d(kernel_size=2),
            nn.Dropout(dropout)
            #54x54x22
        )


        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

model = Model(batch_norm=True)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp5, train_acc_exp5, val_loss_exp5, val_acc_exp5 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp5],
                   val_loss=[val_loss_exp5],
                   train_acc=[train_acc_exp5],
                   val_acc=[val_acc_exp5],
                   labels=['Batchnorm:Dual-conv'],
                   colors=['green'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## <font style="color:green">2.5 Experiment 5: With Dropout [M]</font><a name="M-with_Drop"></a>

Add Dropout Regularization. Add dropout layers with probability, `0.50`.
"""

model = Model(0.25)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp6, train_acc_exp6, val_loss_exp6, val_acc_exp6 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp6],
                   val_loss=[val_loss_exp6],
                   train_acc=[train_acc_exp6],
                   val_acc=[val_acc_exp6],
                   labels=['Dropout: Dual-conv'],
                   colors=['red'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## <font style="color:green">2.6. Experiment 6: With Batch-Norm and Dropout [M]</font><a name="M-with_B_and_Drop"></a>

Apply both Batch Norm and Dropout. See the effect of this double dose.
"""

model = Model(0.25, batch_norm=True)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp7, train_acc_exp7, val_loss_exp7, val_acc_exp7 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp7],
                   val_loss=[val_loss_exp7],
                   train_acc=[train_acc_exp7],
                   val_acc=[val_acc_exp7],
                   labels=['Batchnorm-Dropout'],
                   colors=['purple'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

model = Model(0.25)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp6, train_acc_exp6, val_loss_exp6, val_acc_exp6 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp6],
                   val_loss=[val_loss_exp6],
                   train_acc=[train_acc_exp6],
                   val_acc=[val_acc_exp6],
                   labels=['Dropout: Dual-conv'],
                   colors=['red'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## <font style="color:green">2.7. Experiment 7: With Batch-Norm, Dropout and SE Attention</font><a name="M-with_B_and_Drop"></a>

Apply both Batch Norm, Dropout and SE attention. See the effect of this double dose.
"""

###
class CNN_BATCH_DROP_SE(nn.Module):
    def __init__(self, dropout=0.0):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
        nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
        nn.BatchNorm2d(5),
        nn.ReLU(inplace=True),
        nn.MaxPool2d(kernel_size=2),
        #output 111x111x11

        SE_Block(channel=5, reduction=16),

        nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
        nn.BatchNorm2d(11),
        nn.ReLU(inplace=True),
        nn.MaxPool2d(kernel_size=2),
        nn.Dropout(dropout)
        #54x54x22
        )

        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

model = CNN_BATCH_DROP_SE(dropout = 0.25)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp8, train_acc_exp8, val_loss_exp8, val_acc_exp8 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp8],
                   val_loss=[val_loss_exp8],
                   train_acc=[train_acc_exp8],
                   val_acc=[val_acc_exp8],
                   labels=['Batchnorm-Dropout-SE-Attention'],
                   colors=['purple'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## <font style="color:green">2.8. Experiment 8: With Batch-Norm, Dropout and CBAM Attention</font><a name="M-with_B_and_Drop"></a>

Apply both Batch Norm, Dropout and SE attention. See the effect of this double dose.
"""

###
class CNN_BATCH_DROP_CBAM(nn.Module):
    def __init__(self, dropout=0.0):
        super().__init__()

        # convolution layers
        self._body = nn.Sequential(
        nn.Conv2d(in_channels=3, out_channels=5, kernel_size=3),
        nn.BatchNorm2d(5),
        nn.ReLU(inplace=True),
        nn.MaxPool2d(kernel_size=2),
        #output 111x111x11

        CBAM_Block(channel=5),

        nn.Conv2d(in_channels=5, out_channels=11, kernel_size=3),
        nn.BatchNorm2d(11),
        nn.ReLU(inplace=True),
        nn.MaxPool2d(kernel_size=2),
        nn.Dropout(dropout)
        #54x54x22
        )

        # Fully connected layers
        self._head = nn.Sequential(

            nn.Linear(in_features=11 * 54 * 54, out_features=100),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=100, out_features=50),
            nn.ReLU(inplace=True),
            nn.Dropout(dropout),

            nn.Linear(in_features=50, out_features=2)
        )

    def forward(self, x):
        x = self._body(x)
        x = x.view(x.size()[0], -1)
        x = self._head(x)
        return x

model = CNN_BATCH_DROP_CBAM(dropout = 0.25)
print(model)

optimizer, scheduler = get_optimizer_and_scheduler(model)

model, train_loss_exp9, train_acc_exp9, val_loss_exp9, val_acc_exp9 = main(model,
                                                                           optimizer,
                                                                           scheduler)

plot_loss_accuracy(train_loss=[train_loss_exp9],
                   val_loss=[val_loss_exp9],
                   train_acc=[train_acc_exp9],
                   val_acc=[val_acc_exp9],
                   labels=['Batchnorm-Dropout-CBAM-Attention'],
                   colors=['purple'],
                   model_sizes=['M'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=TrainingConfiguration().class_names,figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=TrainingConfiguration().class_names))

plot_gradcam(model)

"""## 2.9. All Experiment plot together"""

plot_loss_accuracy(train_loss=[train_loss_exp1, train_loss_exp2, train_loss_exp3, train_loss_exp4, train_loss_exp5, train_loss_exp6,train_loss_exp7,train_loss_exp8,train_loss_exp9],
                   val_loss=[val_loss_exp1, val_loss_exp2, val_loss_exp3, val_loss_exp4, val_loss_exp5, val_loss_exp6, val_loss_exp7,val_loss_exp8,val_loss_exp9],
                   train_acc=[train_acc_exp1, train_acc_exp2, train_acc_exp3, train_acc_exp4, train_acc_exp5, train_acc_exp6, train_acc_exp7, train_acc_exp8, train_acc_exp9],
                   val_acc=[val_acc_exp1, val_acc_exp2, val_acc_exp3, val_acc_exp4, val_acc_exp5,val_acc_exp6,val_acc_exp7,val_acc_exp8,val_acc_exp9],
                   labels=['No-reg', 'No-reg', 'SE', 'CBAM','BN', 'DR','BN-DR', 'SE-BN-DR', 'CBAM-BN-DR'],
                   colors=['blue', 'green', 'red','pink', 'purple', 'orange','orange', 'cyan','olive'],
                   model_sizes=['Initial', 'Dual-conv', 'SE:Dual-conv','CBAM:Dual-conv','BN:Dual-conv', 'DR:Dual-conv','BN-DR:Dual-conv','SE-BN-DR:Dual-conv','CBAM-BN-DR:Dual-conv',],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

plot_loss_accuracy(train_loss=[train_loss_exp2, train_loss_exp3, train_loss_exp4, train_loss_exp5, train_loss_exp6,train_loss_exp7,train_loss_exp8,train_loss_exp9],
                   val_loss=[val_loss_exp2, val_loss_exp3, val_loss_exp4, val_loss_exp5, val_loss_exp6, val_loss_exp7,val_loss_exp8,val_loss_exp9],
                   train_acc=[train_acc_exp2, train_acc_exp3, train_acc_exp4, train_acc_exp5, train_acc_exp6, train_acc_exp7, train_acc_exp8, train_acc_exp9],
                   val_acc=[val_acc_exp2, val_acc_exp3, val_acc_exp4, val_acc_exp5,val_acc_exp6,val_acc_exp7,val_acc_exp8,val_acc_exp9],
                   labels=['No-reg', 'SE', 'CBAM','BN', 'DR','BN-DR', 'SE-BN-DR', 'CBAM-BN-DR'],
                   colors=['blue', 'green', 'red','pink', 'purple', 'cyan','orange', 'olive'],
                   model_sizes=['Dual-conv', 'SE:Dual-conv','CBAM:Dual-conv','BN:Dual-conv', 'DR:Dual-conv','BN-DR:Dual-conv','SE-BN-DR:Dual-conv','CBAM-BN-DR:Dual-conv',],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

"""# <font style="color:blue">3. SOTA Models: RESNET18, AlexNet, GoogleNe</font> <a name="model-1"></a>

## 3.1 ResNet18
"""

def pretrained_resnet18(transfer_learning=True, num_class=2):
    resnet = models.resnet18(pretrained=True)

    if transfer_learning:
        for param in resnet.parameters():
            param.requires_grad = False

    last_layer_in = resnet.fc.in_features
    resnet.fc = nn.Linear(last_layer_in, num_class)

    return resnet

"""### <font style="color:red">Training </font>
experiment with
    - Optimizers and learning rate schedulers
    - Regularization techniques like Data Augmentation, Dropout, BatchNorm

"""

model = pretrained_resnet18(transfer_learning=True)
print(model)
# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, sota_train_loss_exp1, sota_train_acc_exp1, sota_val_loss_exp1, sota_val_acc_exp1 = main(model,
                                                                           optimizer,
                                                                           scheduler,
                                                                           data_augmentation=True
                                                                           )

"""### <font style="color:blue"> Loss and Accuracy Plot</font>"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp1],
                   val_loss=[sota_val_loss_exp1],
                   train_acc=[sota_train_acc_exp1],
                   val_acc=[sota_val_acc_exp1],
                   labels=['Resnet'],
                   colors=['blue'],
                   model_sizes=['18'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=['normal','crack'],figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=['normal','crack']))

"""## 3.2 AlexNet"""

def pretrained_alexnet(transfer_learning=True):
    alexnet = models.alexnet(pretrained=True)

    if transfer_learning:
        for param in alexnet.features.parameters():
            param.requires_grad = False

    alexnet.classifier[6].out_features = 2

    return alexnet

"""### Training"""

model = pretrained_alexnet(transfer_learning=True)
print(model)
# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, sota_train_loss_exp2, sota_train_acc_exp2, sota_val_loss_exp2, sota_val_acc_exp2 = main(model,
                                                                           optimizer,
                                                                           scheduler,
                                                                           data_augmentation=True
                                                                           )

"""### Loss and Accuracy Plot"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp2],
                   val_loss=[sota_val_loss_exp2],
                   train_acc=[sota_train_acc_exp2],
                   val_acc=[sota_val_acc_exp2],
                   labels=['AlexNet'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=['present','missing'],figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=['present','missing']))

"""## <font style="color:red"> 3.3 GooGlenet</font>"""

def pretrained_googlenet(transfer_learning=True,num_class=2):
    googlenet = models.googlenet(pretrained=True)

    if transfer_learning:
        for param in googlenet.parameters():
            param.requires_grad = False

    last_layer_in = googlenet.fc.in_features
    googlenet.fc = nn.Linear(last_layer_in, num_class)

    return googlenet

"""### Training"""

model = pretrained_googlenet(transfer_learning=True)
print(model)
# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, sota_train_loss_exp3, sota_train_acc_exp3, sota_val_loss_exp3, sota_val_acc_exp3 = main(model,
                                                                           optimizer,
                                                                           scheduler,
                                                                           data_augmentation=True
                                                                           )

"""### Loss and Accuracy Plot"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp3],
                   val_loss=[sota_val_loss_exp3],
                   train_acc=[sota_train_acc_exp3],
                   val_acc=[sota_val_acc_exp3],
                   labels=['GoogleNet'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=['present','missing'],figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=['present','missing']))

"""## 3.4 MobileNet"""

def pretrained_mobilenetv2(transfer_learning=True):
    mobilenet_v2 = models.mobilenet_v2(pretrained=True)

    if transfer_learning:
        for param in mobilenet_v2.features.parameters():
            param.requires_grad = False

    mobilenet_v2.classifier[1].out_features = 2

    return mobilenet_v2

"""### Training"""

model = pretrained_mobilenetv2(transfer_learning=True)
print(model)
# get optimizer and scheduler
optimizer, scheduler = get_optimizer_and_scheduler(model)

# train and validate
model, sota_train_loss_exp4, sota_train_acc_exp4, sota_val_loss_exp4, sota_val_acc_exp4 = main(model,
                                                                           optimizer,
                                                                           scheduler,
                                                                           data_augmentation=True
                                                                           )

"""### Loss and Accuracy Plot"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp4],
                   val_loss=[sota_val_loss_exp4],
                   train_acc=[sota_train_acc_exp4],
                   val_acc=[sota_val_acc_exp4],
                   labels=['MobileNet'],
                   colors=['blue'],
                   model_sizes=['S'],
                   loss_legend_loc='best',
                   acc_legend_loc='best')

def prediction(model, device, batch_input):

    # send model to cpu/cuda according to your system configuration
    model.to(device)

    # it is important to do model.eval() before prediction
    model.eval()

    data = batch_input.to(device)

    output = model(data)

    # Score to probability using softmax
    prob = F.softmax(output, dim=1)

    # get the max probability
    pred_prob = prob.data.max(dim=1)[0]

    # get the index of the max probability
    pred_index = prob.data.max(dim=1)[1]

    return pred_index.cpu().numpy(), pred_prob.cpu().numpy()

def get_predictions(data_loader,model=None):
  target_labels=[]
  predicted_lables=[]

  for image_data, target in data_loader:
    target_labels.extend(target.tolist())
    preds= prediction(model,device='cuda',batch_input=image_data)
    predicted_lables.extend(preds[0].tolist())
  return target_labels,predicted_lables

from sklearn.metrics import confusion_matrix
train_loader,test_dataloader = get_data(batch_size=32,  data_root=TrainingConfiguration.data_root, num_workers=10, data_augmentation=False)
targets, predictions= get_predictions(test_dataloader, model)
cm = confusion_matrix(targets, predictions)

import pandas as pd
import seaborn as sns
print_confusion_matrix(cm,class_names=['normal','crack'],figsize = (10,7), fontsize=14)

from sklearn.metrics import classification_report
print(classification_report(targets, predictions, target_names=['normal','crack']))

"""## 3.5 Plot all SOTA model together"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp1, sota_train_loss_exp2, sota_train_loss_exp3, sota_train_loss_exp4],
                   val_loss=[sota_val_loss_exp1, sota_val_loss_exp2, sota_val_loss_exp3, sota_val_loss_exp4,],
                   train_acc=[sota_train_acc_exp1, sota_train_acc_exp2, sota_train_acc_exp3, sota_train_acc_exp4,],
                   val_acc=[sota_val_acc_exp1, sota_val_acc_exp2, sota_val_acc_exp3, sota_val_acc_exp4,],
                   labels=['ResNet18', 'AlexNet', 'GoogleNet', 'MobileNet'],
                   colors=['blue', 'green', 'red','pink'],
                   model_sizes=['rs', 'alex', 'google','mobile'],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

plot_loss_accuracy(train_loss=[sota_train_loss_exp1, sota_train_loss_exp2, sota_train_loss_exp3, sota_train_loss_exp4],
                   val_loss=[sota_val_loss_exp1, sota_val_loss_exp2, sota_val_loss_exp3, sota_val_loss_exp4,],
                   train_acc=[sota_train_acc_exp1, sota_train_acc_exp2, sota_train_acc_exp3, sota_train_acc_exp4,],
                   val_acc=[sota_val_acc_exp1, sota_val_acc_exp2, sota_val_acc_exp3, sota_val_acc_exp4,],
                   labels=['ResNet18', 'AlexNet', 'GoogleNet', 'MobileNet'],
                   colors=['blue', 'green', 'red','pink'],
                   model_sizes=['rs', 'alex', 'google','mobile'],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

"""# 4 SOTA vs Custom"""

plot_loss_accuracy(train_loss=[sota_train_loss_exp1, sota_train_loss_exp2, sota_train_loss_exp3, sota_train_loss_exp4,train_loss_exp6,train_loss_exp7,train_loss_exp8,train_loss_exp9],
                   val_loss=[sota_val_loss_exp1, sota_val_loss_exp2, sota_val_loss_exp3, sota_val_loss_exp4,val_loss_exp6, val_loss_exp7,val_loss_exp8,val_loss_exp9],
                   train_acc=[sota_train_acc_exp1, sota_train_acc_exp2, sota_train_acc_exp3, sota_train_acc_exp4,train_acc_exp6, train_acc_exp7, train_acc_exp8, train_acc_exp9],
                   val_acc=[sota_val_acc_exp1, sota_val_acc_exp2, sota_val_acc_exp3, sota_val_acc_exp4,val_acc_exp6,val_acc_exp7,val_acc_exp8,val_acc_exp9],
                   labels=['ResNet18', 'AlexNet', 'GoogleNet', 'MobileNet','DR','BN-DR', 'SE-BN-DR', 'CBAM-BN-DR'],
                   colors=['blue', 'green', 'red','pink','purple','orange', 'cyan','olive'],
                   model_sizes=['rs', 'alex', 'google','mobile','DR:Dual-conv','BN-DR:Dual-conv','SE-BN-DR:Dual-conv','CBAM-BN-DR:Dual-conv'],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

plot_loss_accuracy(train_loss=[sota_train_loss_exp1, sota_train_loss_exp2, sota_train_loss_exp3, sota_train_loss_exp4,train_loss_exp6,train_loss_exp7,train_loss_exp8,train_loss_exp9],
                   val_loss=[sota_val_loss_exp1, sota_val_loss_exp2, sota_val_loss_exp3, sota_val_loss_exp4,val_loss_exp6, val_loss_exp7,val_loss_exp8,val_loss_exp9],
                   train_acc=[sota_train_acc_exp1, sota_train_acc_exp2, sota_train_acc_exp3, sota_train_acc_exp4,train_acc_exp6, train_acc_exp7, train_acc_exp8, train_acc_exp9],
                   val_acc=[sota_val_acc_exp1, sota_val_acc_exp2, sota_val_acc_exp3, sota_val_acc_exp4,val_acc_exp6,val_acc_exp7,val_acc_exp8,val_acc_exp9],
                   labels=['ResNet18', 'AlexNet', 'GoogleNet', 'MobileNet','DR','BN-DR', 'SE-BN-DR', 'CBAM-BN-DR'],
                   colors=['blue', 'green', 'red','pink','purple','orange', 'cyan','olive'],
                   model_sizes=['rs', 'alex', 'google','mobile','DR:Dual-conv','BN-DR:Dual-conv','SE-BN-DR:Dual-conv','CBAM-BN-DR:Dual-conv'],
                   loss_legend_loc='best',
                   acc_legend_loc='best',
                   legend_font = 11,
                   fig_size=(25, 29),
                   sub_plot1=(2, 1, 1),
                   sub_plot2=(2, 1, 2))

